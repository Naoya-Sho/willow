Willow: Experimental Economics with Python
==========================================

//////////////////////////////////////////////////////////////////////
This manual is written in the asciidoc markup language, which can be
compiled into HTML, PDF, and suchlike. It is quite readable as plain
text, too, but if you decide to edit it, please do make sure that it
remains valid asciidoc!
//////////////////////////////////////////////////////////////////////

About this manual
-----------------

You are reading the manual for Willow, a Python framework for
experimental economics developed at the Center for the Study of
Neuroeconomics at George Mason University. This manual presumes that
you already have an understanding of experimental economics, of HTML,
and of Python programming.

If you are interested in learning about experimental economics, you
could do worse than to have a look at the following textbooks:

* Daniel Friedman, 'Experimental Methods: A Primer for Economists'
* John Kagel and Alvin Roth, 'The Handbook of Experimental Economics'

In order to get started with Python if you already know how to program
in some other language, you can try

* Mark Pilgrim, 'Dive into Python'  http://diveintopython.org

* Guido van Rossum et al., 'The Python Tutorial'
  http://docs.python.org/tutorial/

If you want to learn both the craft of computer programming and the
Python programming language at the same time, you are in luck, since
Python is an excellent first language. Some free resources include:

* Jeffrey Elkner, Allen B. Downey, and Chris Meyers, 'How to Think
  Like a Computer Scientist' http://openbookproject.net/thinkCSpy/

* Swaroop C. H., 'A Byte of Python'
  http://www.swaroopch.com/notes/Python

Also, in order to use Willow, you need to have basic knowledge of HTML
and CSS, the languages used to build web pages. For this I strongly
recommend

 * Kennedy and Musciano, 'HTML & XHTML, The Definitive Guide',
   O'Reilly.

O'Reilly books are available full-text through an online service
called Safari, which many universities subscribe to. In particular, if
you are at GMU, you can get Safari at
http://proquest.safaribooksonline.com.mutex.gmu.edu/?uicode=viva and
you can this book at
http://proquest.safaribooksonline.com.mutex.gmu.edu/0596527322 . If
you are at some other institution, try your library web site listing
of online databases.


Why Willow?
-----------

Willow is a tool for making the kinds of computer user interfaces
typically used in experimental economics. Without Willow, you might
design such an interface from scratch, or by modifying earlier
from-scratch software written for similar experiments. Using Willow,
you can do the same thing, but faster and better.

Willow sets out to accomplish this goal not by providing canned
routines for commonly performed experiments. After all, it is
precisely because our experiments are different from what has gone
before that we bother with them. Rather, Willow is a generic toolkit
that makes a lot of the things we do in experimental economics easy.

To use a Willow program, you need only install your program on a
single "monitor" computer. The computers used by your research
subjects will simply run a web browser, which connects to a web server
that runs on the monitor computer. The user interface for the subjects
will be displayed inside the browser window. 

Willow is a versatile program, and you can use it for many different
interfaces; but you might just be curious what a Willow interface can
look like. Here are some examples taken from the first study that used
Willow at the Center for the Study of Neuroeconomics and the
Interdisciplinary Center for Economic Science at George Mason
University.

image::screen1.png[]
image::screen2.png[]

Reading this manual
-------------------

In this manual, I will use +fixed-width font+ to indicate anything
that is literally part of some HTML, CSS or Python code. For longer
snippets of code, I will use boxes, like so:

[source,python]
----------------------------------------------------------------------
import random
print random.random()
----------------------------------------------------------------------

Note that there are colors in these boxes, which are merely a
typesetting convention to make it easier to read the code. Similarly,
you may find that many of the better programmer's text editors will
color your code in a similar (but not identical) way. Again, the
colors are not part of the code, and they are not actually stored in
your code files, as you can easily verify by opening them up in a less
fancy text editor.

Preliminary 1: HTML
-------------------

Willow relies on HTML, the hypertext markup language, for the purpose
of constructing a user interface. A complete description of HTML is
outside the scope of this manual, but I'll give a brief introduction.

An HTML document is a text file with some special markup sequences. To
practice with HTML, you can construct HTML documents with a text
editor, and load them in a web browser.

Consider this example:

[source,html]
----------------------------------------------------------------------
<p>This is a paragraph, with a <b>bold</b> bit in it, and a <br>line
break and a <a href="http://google.com">link</a>.</p>

<ol>
 <li>This is         the first item of an ordered list.</li>
 <li>This is the second        item of an ordered list.</li>
</ol>
<ul>
 <li>This is the first item of an unordered list. </li>
 <li>This is the second item of an unordered list.</li>
</ul>

<div>This is a div. It has a <span>span</span> in it.</div>
<div>This is a div. It has another <span>span</span> in it.</div>
----------------------------------------------------------------------

If we type this into a file called +example.html+ and load that file in
a web browser, this is what we see:

image::html_1.png[]

Even though this is a simple example, it already illustrates some of
the most important points about HTML:

* HTML is made up of _elements_, which are delimited by _tags_. For
  instance, the above example starts with a +p+ element, the start of
  which is marked with an opening tag +<p>+, and the end of which is
  marked with a closing tag +</p>+.

* Elements can have _contents_. For example, the +b+ element in the
  above example contains the text +bold+.

* Some elements, such as +br+, do not have contents, and those do not
  need a closing tag. (Sometimes, you will see these written like +<br
  />+; this is an XML thing, which you can read about elsewhere.)

* Elements also can have _attributes_. In the above example, the +a+
  element has an +href+ _attribute_, with _value_ +http://google.com+.

* In HTML, any sequence of newline characters and/or blank characters
  is always treated as a single blank. Extra blanks, or newlines, in
  the HTML source have no effect. If you do want a line break, you can
  use the the HTML element +<br>+.

* Most HTML elements have standard meanings for the browser. The +b+
  element is rendered by typesetting its contents in bold, the +a+
  element describes a link, etc. Strictly speaking, many of these
  meanings are not part of the HTML standard, but in practice, they
  are pretty consistent across browsers. There are two exceptions to
  the rule that each HTML element has a standard meaning: +div+ and
  +span+. These have no inherent meaning, and only become useful when
  we start using things like CSS. The difference between +div+ and
  +span+ is that a +div+ is typeset above/below whatever comes
  before/after it, while a +span+ is typeset in-line.

Next, we will see a list of common HTML elements. 

+<p>...</p>+::     A paragraph.
+<ul>...</ul>+::   An unordered (bulleted) list.
+<ol>...</ol>+::   An ordered (numbered) list.
+<li>...</li>+::   An item for a list.
+<div>...</div>+:: A generic chunk of text displayed vertically.
+<input>+:: An input widget
+<b>...</b>+:: A piece of text in bold
+<i>...</i>+:: A piece of text in italics
+<span>...</span>+:: A generic chunk of text displayed in-line.
+<a>...</a>+:: A link
+<br>+:: A line break
+<hr>+:: A horizontal line
+<table>+:: A table
+<tr>+:: A table row
+<td>+:: A table element

The last three of these fit together like so:

[source,html]
----------------------------------------------------------------------
<table>
<tr><td>Column 1, Row 1</td><td>Column 2, Row 1</td></tr>
<tr><td>Column 1, Row 2</td><td>Column 2, Row 2</td></tr>
</table>
----------------------------------------------------------------------

Some of the more common HTML attributes:

+<table border='1'>...</table>+:: A table with 1 pixel borders.
+<a href="http://google.com/">...</a>+:: A link to +http://google.com/+
+<input type='submit' value='foo'>+:: A button with label +foo+
+<input type='text'>+:: A text field.

You can learn more about HTML by using either Firefox with the Firebug
plugin, or Google Chrome. Right-click anywhere on the page and select
"Inspect element." This pulls up an HTML explorer system, which looks
like this in Google Chrome (Firefox with the Firebug plugin is
similar):

image::html_2.png[]

By playing around with this feature of your browser, you can learn a
lot of about HTML and CSS. 


Preliminary 2: CSS
------------------

TBA


Preliminary 3: Some Python features
-----------------------------------

You should already know Python before reading this manual, but there
are few Python features that you may not be familiar with even if you
do have experience with Python and that will come in useful for
Willow.

.Format strings

Python has a convenient way of putting together strings with the +%+
operator.

[source,python]
----------------------------------------------------------------------
print "foo %s baz" % ("bar",)
print "foo %s baz %%" % ("bar",)
print "foo %s baz %s" % ("bar", "quux")
print "foo %s baz %s" % ("bar", 42)
print "foo %s baz" % "bar"
----------------------------------------------------------------------

If you run that through Python, you will see

----------------------------------------------------------------------
foo bar baz
foo bar baz %
foo bar baz quux
foo bar baz 42
foo bar baz
----------------------------------------------------------------------

As you can see, the +%+ operator takes a string, called the "format
string", on its left hand side, and a tuple on its right hand
side. For every "gap" in the format string, indicated by +%s+, the
corresponding element from the tuple will be substituted.

In fact, there are a number of gap markers other than +%s+ (such as
+%d+, +%r+, etc.) which are described in the "String Formatting
Operations" section in the "Built-in Types" chapter of the Python
library documentation. In practice, +%s+ is nearly always what you
want. If you happen to actually want a percent sign in your string,
you should use +%%+. 

Also, if you only have one value to substitute, you don't need to put
it in a one-element tuple; the +%+ operator is nice enough to accept
interpret non-tuple values as though they were one-element tuples.

Lesson 0: Wherein we install Willow
-----------------------------------

To install Willow, you extract the zip file to a convenient
location. You will do this anew for each of your Willow projects.  In
addition, you will need to have Python installed. Willow has been
tested using Python 2.6 on Ubuntu GNU/Linux. You should be able to use
it with Python 2.6 on Windows and Mac OSX as well. If you do not have
Python 2.6 on your computer, get it from
http://www.python.org/download/releases/2.6.3/ and then come back. If
you are not sure whether you have Python 2.6 on your computer, just
move on to the next section of the manual. If things don't work,
you'll notice soon enough, and you can go back and install Python. Do
not use Python version 3. It will not work.

While programming, you will want to run Willow from within a
programmer's text editor (or, if you care for such things, an
Integrated Development Environment). On Mac and Linux, you can use the
IDLE editor that ships with Python. If you are running Windows, the
version of IDLE that ships with Python on that platform is very buggy,
and I recommend strongly that you get a different text editor: in
particular, I recommend SciTE, which is a very simple drop-in
replacement for IDLE. On Mac or Linux, you can get away with just
using IDLE, although you may find that SciTE is a little more
polished. Either way, SciTE can be had from
http://www.scintilla.org/SciTE.html .

Lesson 1: Wherein we meet Willow
--------------------------------

In the Willow folder, you will find a file named +lesson.01+. You need
to run this file: double click on it, or run the command +python
lesson01.py+ from the command line. Once the +lesson01.py+ program is
running, fire up a web browser and point it to
+http://localhost:8000/+. You should see a page that looks like so:

image::lesson01_1.png[]

Now pull up the +lesson01.py+ file in IDLE or SciTE.

In IDLE, this looks like so:

image::lesson01_2.png[]

In Scite, it looks like:

image::lesson01_3.png[]

See here the code of a very simple but working Willow program. You can
run it using the +Run > Run Module+ menu option in IDLE or the +Tools
> Go+ menu in SciTE, or by pressing +F5+ (that shortcut key is the
same in both SciTE and IDLE). 

Again, you now need to point a web browser to +http://localhost:8000+.

If you see an error message like "address already in use," you are
probably trying to run two instances of Willow simultaneously. You
should stop the first one first (just close the window).

Now, let us look at the above code. Most of it is boilerplate, but the
good news is that this is all the boilerplate you need. The first line
imports the willow library. It assumes that +willow.py+ is in a
subdirectory +willow+ of the directory in which +lesson01.py+ is; this is
how things are set up for the sample programs, and if you put your own
programs in the same place, it will just work. The next two lines
define a session function, and the last line instructs Willow to start
the web server, using the session function that has just been defined.

Together, these four lines define a web server that you can connect to
from a browser. If the browser is running on the same machine as the
server, you can use +http://localhost:8000+ as a URL. If it is running
somewhere else, you must find out the IP address of the server. (If
you don't know it, there is a whole chapter further down in the manual
about how to figure it out.) If the IP address is, say,
+123.123.123.123+, then you can reach your Willow server using
+http://123.123.123.123:8000+. The +:8000+ part is called the port
number; you can specify a different port number as an extra argument
to +run+ (e.g. +run(session, 8001)+) if you insist on a port different
from 8000.

Once the web server is running, for each client that connects to it,
the session function will be called once. It will keep running until
it returns. We say that each session function runs in its own "session
thread". This means that several "copies" of the session function are
running simultaneously, one for each client.

In this case, we want to simply display the text "Hello world." in the
web browser of every client that connects, so we have a very simple
session function that does nothing but +add("<h1>Hello,
world.</h1>")+. The +add()+ function adds an HTML snippet to the web
page being displayed in the client's browser. 

Try connecting to +localhost:8000+ in multiple browser tabs. You'll
see that each one shows "Hello, world." This is because the
+session()+ function gets called once for each client that connects.

Lesson 2: Wherein all clients are not equal
-------------------------------------------

In real applications, we usually do not want to do the same for every
client that connects. More likely, we'll want one client to show some
sort of experimenter console, one client to show the interface for
subject 1, one client the interface for subject 2, etc.

Have a look at +lesson02.py+:

[source,python]
----------------------------------------------------------------------
include::lesson02.py[tabsize=2]
---------------------------------------------------------------------- 

NOTE: The +%+ operator in Python is very useful for constructing
strings. You can read about it in section 6.6.2, "String Formatting
Operations", of the Python 2.6.4 Standard Library reference manual.

As you can see, there is still only one +session()+ function, and for
each client that connects, a session thread is started that runs the
+session()+ function. Each client runs the exact same function,
but... the session function takes an argument, which we call +me+, and
for each client, it gets called with a different value for +me+: 0, 1,
2, and so on. If you reload the page a bunch of times, it looks like
this:

image::lesson02_1.png[]
image::lesson02_2.png[]
image::lesson02_3.png[]

Lesson 3: Wherein we produce output
-----------------------------------

In this lesson, we will see some of the Willow functions for
manipulating user interface elements. All of these are based on HTML
and CSS, and it is crucial that you acquire a basic understanding of
these languages. An extensive description of HTML and CSS is outside
the scope of this manual.

Have a look at +lesson03.py+. 

[source,python]
----------------------------------------------------------------------
include::lesson03.py[tabsize=2]
---------------------------------------------------------------------- 

This displays a web page like so:

image::lesson03_1.png[]

This shows off all of Willow's UI manipulation functions. Let's go
through it line by line.

    add("<style type='text/css'>.important { font-weight: bold; }</style>")

First we add a style sheet to the page. Again, CSS is beyond the scope
of this manual and you should go out and read up on it, but what this
comes down to is that we instruct the browser to typeset in bold all
HTML elements that have class "important" turned on.

    add("<p>The <span class='important' id='a'>division</span> of "
        "<span class='b'>labor</span> is limited "
        "by the extent of the "
        "<a href='http://ebay.ocm>market</a>.")

Note that in Python string literal juxtaposition adds the string
literals together, which makes for a convenient way of splitting long
strings over several lines.

The +<span>+ element in HTML has no default meaning, and without any
style sheets or other manipulations, a piece of HTML enclosed in a
+<span>+ is exactly identical to the same piece of HTML not so
enclosed. In the above fragment, we have two +<span>+ elementss. Note
that because the style sheet instructed the browser to print all
elements of class +important+ in bold, the word "division" is printed
in bold; or at least, it would be, if we did not manipulate it
further.

    add(" and subdivision", "#a")

This shows that you can add text not just to the page as a whole, but
also to particular elements. The optional second argument to +add+ is
a CSS selector. The most common CSS selectors are:

 * +p+, which refers to all +<p>+ elements;
 * +h1+, which refers to all +<h1>+ elements;
 * etc.;
 * +.x+, which refers to all elements with +class='x'+;
 * +#a+, which refers to the first element with +id='a'+.

Note that some selectors can refer to more than one element, and in
that case, your HTML snippet gets added to all matching elements.

In this case, what we are asking Willow to do is to find the first
HTML element with +id='a'+ and add the text " and subdivision" to the
end of it it.

    set("labour", ".b")

The +set()+ function is just like the +add()+ function except that
instead of adding HTML to the end of some element, it replaces the
entire contents of the element. In particular, +set("")+ clears the
entire page!

    poke("href", "http://ebay.com", "a")

So far, we have seen the functions +add+ and +set+ that manipulate the
contents of HTML elements. But HTML elements have attributes as well
as contents. For instance, if you write +<a href="foo">...</a>+, you
have created an +<a>+ element with contents "..." and with an +href+
attribute with value +foo+. The +poke()+ function serves to
manipulate attributes. In this case, we set the +href+ attribute of
*every single +<a>+ element on the page* to be +http://ebay.com+.

    pop("important","#a")
    push("important",".b")    

In HTML, a single element can have more than one class. You can write
that as +<p class='class1 class2'>...</p>+. The +pop()+ and +push()+
functions are there to remove a class from an element and to add a
class to an element, respectively, without changing any other classes
that the element might have.

    add("<p class='elusive'>Microfoundations.</p>")
    add("<p class='hidden'>Prices.</p>")    
    hide(".elusive")
    show(".hidden")

The +hide()+ and +show()+ functions do just that: hide and show
elements. Willow is set up so that any element with class +hidden+ set
is hidden by default and only shows up when you call +show()+ on it.

So far, we have seen the Willow UI primitives: +add+, +set+, +poke+,
+push+, +pop+, +hide+, and +show+. In combination with HTML and CSS,
these primitives make a very powerful UI language. 

Lesson 4: Wherein we chatter
----------------------------

Now that we have seen how to produce output on the client screens, you
may be wondering how we can read input. But before we get to that, we
will first discuss another important feature of Willow: its
communication system.

Consider +lesson04.py+. 

[source,python]
----------------------------------------------------------------------
include::lesson04.py[tabsize=2]
---------------------------------------------------------------------- 

In this short program, we can see a typical use case for the important
Willow functions +put()+ and +take()+. The first client, for which
+me==0+, acts as a control panel that displays information about other
clients coming online. In order to convey that information, each
client other than the first puts a dictionary +{"tag":"HELLO",
"number":me}+ on the Board. The first client retrieves these
dictionaries and uses them to display information about logins.

After the monitor client and 3 other clients have connected, the
monitor client display would look like this:

image::lesson04_1.png[]

To fully understand this, we must understand the Board. The Board is
the one and only data structure that is shared between the various
session threads in Willow.  

The board contains dictionaries. Dictionaries are sets of key-value
pairs. To put +_my_dictionary_+ on the board, you call
+put(_my_dictionary_)+. For instance, to put the empty dictionary +{}+
on the board, you call +put({})+, or to put the very abridged
Dutch-to-English dictionary +{"rood":"red","nederlands":"dutch"}+ on
the board, you call +put({"rood":"red","nederlands":"dutch"})+.

To retrieve +_my_dictionary_+ from the board, you call
+take(_my_dictionary_)+. In practice, though, you typically don't know
yet what dictionary you want to retrieve. For that reason, +take()+
allows you to leave out keys you aren't sure of. In the extreme case,
you leave out all keys and call +take({})+, which means "please
retrieve any dictionary whatsoever from the board."

The +take()+ function is blocking. This means that if there is no
matching dictionary on the board, it will sit around waiting until one
appears. This is what happens in the example code: the first thread
(the one with +me==0+) sits around waiting for dictionaries of the
form +{"tag":"HELLO", ...}+ to show up on the board. Every time one
such dictionary shows up, the +take()+ function returns it, the loop
loops, and the +take()+ function is called again, blocking until the
next dictionary shows up.

When a dictionary is gotten with +take()+, it is removed from the
board. Therefore, in the above code, you do not need to worry about
looping around retrieving the same dictionary over and over again. If you
want to retrieve a dictionary and leave it available (maybe for some other
thread), you simply put it back on with +put()+.

Another important trick in the use of +take()+ is that you can specify
more than one pattern. For instance, +take({"tag":"HELLO"},
{"tag":"ERROR"})+ blocks until either a dictionary with the key-value
pair +"tag":"HELLO"+ or a dictionary with the key-value pair
+"tag":"ERROR"+ shows up. +take({"tag":"HELLO"}, {"foo":3})+ blocks
until either a dictionary with the key-value pair +"tag":"HELLO"+ or a
dictionary with the key-value pair +"foo":3+ shows up. And so on.

Finally, I will mention +grab()+. It is like +take()+, except that it
does not block. If a matching dictionary is available, it will return that,
but if there is none, it will simply return +None+ (unlike +take()+,
which will sit there twiddling its thumbs until a matching dictionary shows
up).

NOTE: You could, conceivably, have your own shared data structures
simply by declaring some global variables outside of +session()+, but
I recommend that you don't. In order to make sure your data structures
remain consistent, you would have to implement rules to make sure that
no two threads fiddle with them at the same time ("mutual exclusion"),
which can rapidly become extremely complicated. The Board is a variant
on a data structure known as a Tuple Space, which already has mutual
exclusion built into it.

Lesson 5: Wherein we deal with input
------------------------------------

Now that we have seen how to manipulate what appears on a client
screen, we will turn our attention to the issue of input.

There are two basic ways of giving input to a Willow client: you can
click things, and you can fill out text fields.

The +lesson05.py+ code demonstrates both.

[source,python]
----------------------------------------------------------------------
include::lesson05.py[tabsize=2]
---------------------------------------------------------------------- 

This should initially display a screen that looks like so:

image::lesson05_1.png[]


You can then type something in the text box and click the button
labeled "Submit", and the screen will look like:

image::lesson05_2.png[]

What's going on here?

First of all, HTML elements that look like

  <input type='submit' ...>

are buttons.

In HTML, each +<input>+ element that is a button must have two
attributes: +type+ must be set to +submit+, to make sure we are
displaying a button and not some other sort of input element, and
+value+ must be set to the text that is to be on the button (or, if it
is left out, the text defaults to "Submit", or possibly something else
if your browser is set up for a language other than English).

In Willow, your button must additionally have an +id+ attribute, which
is how we keep track of which buttons get clicked.

When a button gets clicked, a dictionary 

 {"tag": "click", "id":_id_, "client":_n_, "time":_t_}

is automatically posted onto the board, where

 * +_n_+ is the number of the client that received the button click;
 * +_id_+ is the +id+ of the button;
 * +_t_+ is the time in milliseconds since Jan 1, 1970 0:00 UTC,
   as measured by the client, when the button was clicked

This is why, after we have displayed the button, we can just call
+take({"tag":"click", "id": "go", "client": me})+, which will block
until the button is clicked. Note that if you insist on blocking one
client thread until a button in some _other_ client thread has been
clicked, you can do that, simply by replacing +me+ in the above call
to +take()+ by some other integer (but it is not recommended).

NOTE: If the button is clicked multiple times, multiple dictionaries
will be inserted. This may result in behavior you may not necessarily
intend. If you want to wait for a button to get clicked that may have
been clicked before you started waiting, you will need to clear those
old dictionaries off the board using +grab()+.

The way we deal with text fields is similar to the way we deal with
buttons, but there is no natural moment to automatically insert the
contents of a text field into the Board, so instead we have to request
it explicitly.

To show a text field, we use a piece of HTML that looks like

  <input id='name_of_text_field' type='text'>

and then we call +peek("#_name_of_text_field_")+. This will cause a
dictionary to be posted to the board of the form 

 {"tag":"peek", "id":_id_, "client":_n_, "time":_t_, "value":_val_}

where

 * +_n_+ is the number of the client that received the button click;
 * +_id_+ is the +id+ of the button;
 * +_t_+ is the time in milliseconds since Jan 1, 1970 0:00 UTC,
   as measured by the client, when the value was checked;
 * +_val_+ is the contents of the text box

You can also use +peek()+ for checkboxes, radioboxes, +<textarea>+
elements, and most other input-type elements that you can read about
in HTML books.

In the above case, we only start looking for what's in the field after
the user has pressed the button.

Lesson 6: Wherein we poke around in other threads
-------------------------------------------------

Many of the Willow functions, even though by default they operate on
the client display associated with the current session thread, can
also operate on a different client display if you pass the
+client=_n_+ optional parameter. This is never necessary, but it may
be more convenient than passing messages through the board to the
other session thread so that it can then manipulate its corresponding
client display.

Take for instance the code in lesson 4:

[source,python]
----------------------------------------------------------------------
include::lesson04.py[tabsize=2]
---------------------------------------------------------------------- 

We could rewrite that as follows:

[source,python]
----------------------------------------------------------------------
include::lesson06.py[tabsize=2]
---------------------------------------------------------------------- 

NOTE: Strictly speaking, the above programs are not entirely
equivalent. If the first session thread executed very, very slowly and
the second client connect immediately after the first, then the
"Client 1 logged in" message could conceivably show up before the
"Monitor" heading when running the second program, but not when
running the first. 

Lesson 7: Wherein we stall for time
-----------------------------------

Look at this:

[source,python]
----------------------------------------------------------------------
include::lesson07.py[tabsize=2]
---------------------------------------------------------------------- 

It shows "Hello, " on the screen, and 2.3 seconds later, it adds "
world."

That's all there is to this one. Use the +background(_f_,_dt_)+
function to call the function +_f_+ in the background, after a delay in
seconds of +_dt_+. Note that you can also use this (typically with
+dt=0+) for any other background tasks, like dealing with a chatbox
while the main task deals with the rest of the experiment.

Lesson 8: Wherein we finally produce data
-----------------------------------------

[source,python]
----------------------------------------------------------------------
include::lesson08.py[tabsize=2]
---------------------------------------------------------------------- 

This is how you cause your Willow program to produce a data file. 

In this case, a data file was produced in the +log+ subdirectory
(i.e. folder) called +2010-02-23-22-00-05.csv+. The name is chosen
automatically based on the date and time
(year-month-day-hour-minute-second).

The file contains:

----------------------------------------------------------------------
1266985186.84,hello,world,0
1266985187.28,hello,world,1
1266985187.55,hello,world,2
1266985187.76,hello,world,3
----------------------------------------------------------------------

This is a CSV file, which is a simple text-file based spreadsheet
format. It is understood by Excel, OpenOffice, Stata, and other data
analysis software. You can also just open it in a text editor.

Each row will automatically get a timestamp added to the front of it,
which is a large integer representing the number of seconds that have
passed since the "Unix epoch" on January 1, 1970, 0:00 UTC. This may
seem like an odd choice of timestamp format, but the advantage of this
type of timestamp is that it makes sense to subtract them! 

Lesson 9: Wherein we program our first experiment
-------------------------------------------------

.lesson09.py
[source,python]
----------------------------------------------------------------------
include::lesson09.py[tabsize=2]
---------------------------------------------------------------------- 

.lesson09_0.html
[source,python]
----------------------------------------------------------------------
include::lesson09_0.html[tabsize=2]
---------------------------------------------------------------------- 

.lesson09_1.html
[source,python]
----------------------------------------------------------------------
include::lesson09_1.html[tabsize=2]
---------------------------------------------------------------------- 

API: willow.willow
------------------

.The +selector+ argument on several API functions:

The +selector+ argument can take any CSS selector. The CSS selector
mini-language is rather rich, but the most typical cases are things
like +p+ (to get at all +<p>+ elements), +#a+, (to get at the first
element with +id="a"+), and +.a+ (to get at all elements with
+class="a"+). For more information, consult any book or web page on
CSS. Whenever +selector+ is omitted, the selector "+body+" is implied,
which means you are referring to the entire body of the HTML
document. Aside from CSS selectors, jQuery extensions are also
allowed. The most useful is of the form +_selector_:eq(_n_)+, which
selects the _n_-th element that matches +_selector_+.

.The +clients+ argument on several API functions:

By specifying an integer, or a sequence of integers, for
+clients+, you can operate directly on clients other than the one
associated by default with the current session thread.

.The +timestamp+ argument on several API functions:

Whenever +timestamp=True+, you are requesting a tuple to be posted
of the form +{"tag":"timestamp","client":_n_,"time":_t_}+ that gives
you a millisecond timestamp of when the action was executed by the
client.

.The +delay+ argument on several API functions:

Whenever you specify the +delay=_dt_+ option, the execution of
that action is delayed by +_dt_+ seconds (you can specify fractions of
seconds, too). This is done on the client side with millisecond
accuracy. 

If you have lots of closely spaced delayed events, at some point the
browser may start lagging; but in Google Chrome, I have gotten it up
to a +set()+ event every milisecond with only a very slight lag.

=== +set(content, [selector], [clients], [timestamp], [delay])+

Set the content of the HTML element(s) referred to by +selector+ on to
be +content+. Whenever +content+ is a file descriptor that can be
read from, the contents of the file are automatically substituted.

=== +add(content, [selector], [clients], [timestamp], [delay])+

Add +content+ to the content of the HTML element(s) referred to by
+selector+. Whenever +content+ is a file descriptor that can be
read from, the contents of the file are automatically substituted.

=== +poke(attribute, value, [selector], [clients], [timestamp], [delay])+

Change the value of attribute +attribute+ to be +value+ in HTML
element(s) referred to by +selector+.

=== +peek([selector], [clients], [timestamp], [delay])+

Request the value of the HTML +<input>+ or +<textarea>+ element(s)
referred to by +selector+ to be posted as
+{"tag":"peek","id":_id_,"client":_n_,"time":_t_,"value"=_value_}+

=== +push(style, [selector], [clients], [timestamp], [delay])+

Add the CSS style +style+ to the HTML element(s) referred to by
+selector+.

=== +pop(style, [selector], [clients], [timestamp], [delay])+

Remove the CSS style +style+ from HTML element(s) referred to by
+selector+.

=== +hide([selector], [clients], [timestamp], [delay])+

Hide the HTML element(s) referred to by +selector+.

=== +show([selector], [clients], [timestamp], [delay])+

Show the HTML element(s) referred to by +selector+, if previously
hidden.

=== +put(dictionary)+

Post the dictionary onto the communication board. 

=== +take(*queries)+

Block until a dictionary becomes present on the board that matches at
least one of the queries, then remove and return it. A dictionary
matches a query if it contains all the key-value pairs in the query
(plus, optionally, some others).

=== +grab(*queries)+

If a dictionary is present on the board that matches at least one of
the queries remove and return it; otherwise return +None+. A
dictionary matches a query if it contains all the key-value pairs in
the query (plus, optionally, some others).

=== +run(session, [port])+ 

This starts the Willow web server on the specified port (or port
8000 if you leave the second argument out). The web server will
create a thread for each client that connects, and each thread will
run the +session+ function, passing as an argument the client ID.

Client IDs will be assigned sequentially, unless the URL is of the
form +http://_whatever-host_/_n_+, where +_n_+ is an integer, and
+_n_+ is not taken yet, in which case the client ID will be +_n_+.

The web server will search for requested files in the current
directory, among other places, so you can for instance include images
in your pages.

=== +background(fn, delay)+

Run the function +fn+ in the background (as a separate thread), with
an initial +delay+ specified in seconds. Fractions of seconds are
allowed.

=== +sleep(delay)+

Wait for +delay+ seconds. Fractions of seconds are allowed.

+log(x,y,...)+
~~~~~~~~~~~~~~

Write (x,y,...) to the log file as a record, with the number of
milliseconds since January 1, 1970 0:00 UTC prepended as the first
column. A new log file is created in the +log+ folder whenever the
Willow library is loaded, and it bears a name based on the date and
time when it was created. For instance, if Willow was invoked at
15:32:42 on February 2 of the year 2010, the file would be called
+log/2010-02-10-15-32-42.csv+.  This particular date-and-time format
is used so that the files can be sorted by date/time. The log files
are in CSV format and can be opened with a text editor or a
spreadsheet program.

CSS features
~~~~~~~~~~~~

Some Willow features are accessed by means of CSS classes:

+hidden+::

	Any element that has class +hidden+ turned on will start out
	hidden. You can call +show()+ on it to make it
	appear. Example: +<p>At the moment, you can<span
	class="hidden">not</span> trade widgets.</p>+

+bait+::

	Any element that has class +bait+ turned on will automatically
	get the additional class +mouse+ turned on whenever the mouse
	pointer is positioned over that element. This can be used to
	create "hover" effects.

Mouse clicks
~~~~~~~~~~~~

When a button with (whether +<input type="submit">+ or
+<button></button>+) or any element with +class="clickable"+ is
clicked, a dictionary like is inserted into the board automatically
behind the scenes like so:

 {"tag":"click", "id":_id_, "client":_n_, "time":_t_, "value":_val_}

where

 * +_n_+ is the number of the client that received the button click;
 * +_id_+ is the +id+ of the button;
 * +_t_+ is the time in milliseconds since Jan 1, 1970 0:00 UTC,
   as measured by the client, when the value was checked;
 * +_val_+ is the contents of the text box

Key presses
~~~~~~~~~~~

When the user presses a key, a dictionary like is inserted into the
board automatically behind the scenes like so:

 {"tag":"key", "client":_n_, "time":_t_, "value":_val_}

where

 * +_n_+ is the number of the client that received the button click;
 * +_t_+ is the time in milliseconds since Jan 1, 1970 0:00 UTC,
   as measured by the client, when the value was checked;
 * +_val_+ is the key pressed

Branch
------

This is an extension library. It is liable to change, much faster than
Willow itself, and not be be as well documented and tested. But I
don't want to withhold it either. This documentation is generated
directly from the +branch.py+ source file.

include::branch.txt[tabwidth=2]


Appendix: A digression on your IP address
-----------------------------------------

You need the IP address of your monitor computer in order for your
client computers to connect to it. It would be convenient if Willow
could display the right IP address for you to use, but unfortunately,
this is easier said than done, since a computer can have multiple IP
addresses at the same time: IP version 4 and IP version 6, on the
wireless network, on the ethernet network, on the "loopback" network,
and so on.

How to find your IP address on Linux
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On Linux on my computer, I use the +ifconfig+ command at the command
line. When I enter

----------------------------------------------------------------------
$ ifconfig
----------------------------------------------------------------------

the computer responds

----------------------------------------------------------------------
$ ifconfig
eth1      Link encap:Ethernet  HWaddr 00:23:ae:1e:9e:ac  
          UP BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
          Interrupt:17 

eth2      Link encap:Ethernet  HWaddr 00:24:2b:c6:a4:76  
          inet addr:10.143.91.80  Bcast:10.143.91.255  Mask:255.255.254.0
          inet6 addr: fe80::224:2bff:fec6:a476/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:10076 errors:0 dropped:0 overruns:0 frame:7868
          TX packets:10906 errors:20 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1571308 (1.5 MB)  TX bytes:1341157 (1.3 MB)
          Interrupt:17 Base address:0xc000 

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:85540 errors:0 dropped:0 overruns:0 frame:0
          TX packets:85540 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:41237280 (41.2 MB)  TX bytes:41237280 (41.2 MB)
$
----------------------------------------------------------------------

TIP: In this and many other software manuals, +$+ is used to indicate
the Linux/UNIX prompt. On your computer, it may be different. +%+ is a
popular choice, too, for example.

There is much information here, but we only need a little. First,
notice that this computer has three network interfaces, called +eth1+,
+eth2+ and +lo+. +lo+ is the loopback device; it does not correspond
to any actual hardware, but it is rather a contraption that the
operating system uses so that you can make connections to your own
machine at address +127.0.0.1+ even when the network is down. The
other two network devices are actual network cards that are in the
computer; as it happens, +eth1+ is a wired Ethernet network, and
+eth2+ is a wireless 802.11g network. According to the information
above, the computer has IP address 10.143.91.80 on +eth2+, and it has
no IP address on +eth1+, which makes sense, because the wired
connection was not plugged when I executed the command. In the output
above you can also see IP v6 addresses (labeled +inet6 addr+), but
those are not commonly used.

How to find your IP address on Windows
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Press _WINDOWS_+R (where _WINDOWS_ is the "Windows Key", the one with
the flag) to pull up a "Run Program" dialog, then enter +cmd+ to get a
command prompt window. Now enter +ipconfig /a+. This should give you
all the information you need.


Appendix: Kiosk mode browsing
-----------------------------

In order to prevent subjects from fiddling around with the web browser
used to display a user interface to them, you can use a "kiosk mode"
web browser. While several web browsers have kiosk modes, I have found
that Google Chrome is the most convenient. On Linux, you simply use
the command line +google-chrome --kiosk+ instead of just
+google-chrome+, and you get a full-screen browser without any
extraneous bits of user interface that subjects might accidentally
click on. 

Appendix: Internals
-------------------

[verse,Blaise Pascal,Lettres Provinciales]
______________________________________________________________________
Je n'ai fait celle-ci plus longue que parce que je n'ai pas eu le
loisir de la faire plus courte.
______________________________________________________________________

The first thing that should strike you when looking at these files is
that there's not very much there. This is on purpose, and took a lot
of work. It is my experience that the number of bugs per 100 lines of
code is roughly constant, and that the best way of limiting the number
of bugs is to limit the amount of code. (In the extreme case, of
course that means that the only way to have no bugs is to write no
code. This is not as vacuous an observation as it seems: it pays to
think twice before deciding to turn something into a computer program
in the first place.)

image::architecture.png[]

.willow.py
[source,python]
----------------------------------------------------------------------
include::willow.py[tabsize=2]
----------------------------------------------------------------------

.willow.html
[source,html]
----------------------------------------------------------------------
include::willow.html[tabsize=2]
----------------------------------------------------------------------

.willow.css
[source,css]
----------------------------------------------------------------------
include::willow.css[tabsize=2]
----------------------------------------------------------------------

.willow.js
[source,javascript]
----------------------------------------------------------------------
include::willow.js[tabsize=2]
----------------------------------------------------------------------



