<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article lang="en">
<articleinfo>
    <title>Willow, a Python framework for experimental economics</title>


</articleinfo>
<section id="_about_this_manual">
<title>About this manual</title>
<simpara>You are reading the manual for Willow, a Python framework for
experimental economics. This manual presumes that you already have an
understanding of experimental economics, of HTML, and of Python
programming.</simpara>

<simpara>If you are interested in learning about experimental economics, you
could do worse than to have a look at the following textbooks:</simpara>

<itemizedlist>
<listitem>
<simpara>
Daniel Friedman, <emphasis>Experimental Methods: A Primer for Economists</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
John Kagel and Alvin Roth, <emphasis>The Handbook of Experimental Economics</emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>In order to get started with Python if you already know how to program
in some other language, you can try</simpara>

<itemizedlist>
<listitem>
<simpara>
Mark Pilgrim, <emphasis>Dive into Python</emphasis>
</simpara>
<literallayout class="monospaced">http://diveintopython.org</literallayout>
</listitem>
<listitem>
<simpara>
Guido van Rossum et al., <emphasis>The Python Tutorial</emphasis>
</simpara>
<literallayout class="monospaced">http://docs.python.org/tutorial/</literallayout>
</listitem>
</itemizedlist>
<simpara>If you want to learn both the craft of computer programming and the
Python programming language at the same time, you are in luck, since
Python is an excellent first language. Some free resources include:</simpara>

<itemizedlist>
<listitem>
<simpara>
Jeffrey Elkner, Allen B. Downey, and Chris Meyers, <emphasis>How to Think
  Like a Computer Scientist</emphasis>
</simpara>
<literallayout class="monospaced">http://openbookproject.net/thinkCSpy/</literallayout>
</listitem>
<listitem>
<simpara>
Swaroop C. H., <emphasis>A Byte of Python</emphasis>
</simpara>
<literallayout class="monospaced">http://www.swaroopch.com/notes/Python</literallayout>
</listitem>
</itemizedlist>
</section>
<section id="_why_willow">
<title>Why Willow?</title>
<simpara>Willow is a tool for making the kinds of computer user interfaces
typically used in experimental economics. Without Willow, you might
design such an interface from scratch, or by modifying earlier
from-scratch software written for similar experiments. Using Willow,
you can do the same thing, but faster and better.</simpara>

<simpara>Willow sets out to accomplish this goal not by providing canned
routines for commonly performed experiments. After all, it is
precisely because our experiments are different from what has gone
before that we bother with them. Rather, Willow is a generic toolkit
that makes a lot of the things we do in experimental economics easy.</simpara>

<simpara>To use a Willow program, you need only install your program on a
single "monitor" computer. The computers used by your research
subjects will simply run a web browser, which connects to a web server
that runs on the monitor computer. The user interface for the subjects
will be displayed inside the browser window.</simpara>

</section>
<section id="_installing_willow">
<title>Installing Willow</title>
<simpara>To install Willow, you extract the zip file to a convenient
location. You will do this anew for each of your Willow projects.  In
addition, you will need to have Python installed. Willow has been
tested using Python 2.6 on Ubuntu GNU/Linux. You should be able to use
it with Python 2.6 on Windows and Mac OSX as well. If you do not have
Python 2.6 on your computer, get it from
<ulink url="http://www.python.org/download/releases/2.6.3/">http://www.python.org/download/releases/2.6.3/</ulink> and then come back. If
you are not sure whether you have Python 2.6 on your computer, just
move on to the next section of the manual. If things don't work,
you'll notice soon enough, and you can go back and install Python. Do
not use Python version 3. It will not work.</simpara>

</section>
<section id="_using_willow">
<title>Using Willow</title>
<simpara>Willow works very similarly on different operating systems, but from
here on I am going to assume that you use Windows. In the Willow
folder, you will find a file named <literal>hello.py</literal>. You need to run this
file by double-clicking on it. Once the <literal>hello.py</literal> program is running,
fire up a web browser and point it to <literal>http://localhost:8000</literal>. You
should see a page that looks like so:</simpara>

<sidebar>
<simpara>Hello World.</simpara>

</sidebar>
<simpara>In practice, while programming, you will want to run Willow from
within IDLE, which is the integrated development environment that
comes with Python. To do so, right-click <literal>hello.py</literal> and select "Edit
with IDLE". This will pop up an editor window with the <literal>hello.py</literal> code
in it:</simpara>

<programlisting language="python" linenumbering="unnumbered">
<![CDATA[from willow.willow import *

def session():
  add("<h1>Hello, world.</h1>")

run(session)]]>
</programlisting>
<simpara>See here the code of a very simple but working Willow program. You can
run it using the <literal>Run &gt; Run Module</literal> menu option or by pressing
<literal>F5</literal>. Again, you now need to point a web browser to
<literal>http://localhost:8000</literal>.</simpara>

<simpara>If you see an error message like "address already in use," you are
probably trying to run two instances of Willow simultaneously. You
should stop the first one first (just close the window).</simpara>

<simpara>Now, let us look at the above code. Most of it is boilerplate, but the
good news is that this is all the boilerplate you need. The first line
imports the willow library. It assumes that <literal>willow.py</literal> is in a
subdirectory <literal>willow</literal> of the directory in which <literal>hello.py</literal> is; this is
how things are set up for the sample programs, and if you put your own
programs in the same place, it will just work. The next two lines
define a session function, and the last line instructs Willow to start
the web server, using the session function that has just been defined.</simpara>

<simpara>Together, these four lines define a web server that you can connect to
from a browser. If the browser is running on the same machine as the
server, you can use <literal>http://localhost:8000</literal> as a URL. If it is running
somewhere else, you must find out the IP address of the server. If the
IP address is, say, 123.123.123.123, then you can reach your Willow
server using <literal>http://123.123.123.123:8000</literal>. The <literal>:8000</literal> part is called
the port number; you can specify a different port number as an extra
argument to <literal>run</literal> (e.g. <literal>run(session, 8001)</literal>) if you insist on a port
different from 8000.</simpara>

<simpara>Once the web server is running, for each client that connects to it,
the session function will be called once. It will keep running until
it returns. Each session function runs in its own thread. This means
that several "copies" of the session function are running
simultaneously.</simpara>

<simpara>In this case, we want to simply display the text "Hello world." in the
web browser of every client that connects, so we have a very simple
session function that does nothing but <literal>add("&lt;h1&gt;Hello,
world.&lt;/h1&gt;")</literal>. The <literal>add()</literal> function adds an HTML snippet to the web
page being displayed in the client's browser.</simpara>

</section>
<section id="_a_digression_on_html_the_hypertext_markup_language">
<title>A digression on HTML, the hypertext markup language</title>
<simpara>In order to use Willow, it is necessary that you understand some HTML,
because HTML is the language of web pages, and the user interface for
a Willow program is made up of web pages. This manual will not go into
detail about HTML, but here is a summary of some of the most common
HTML tags:</simpara>

<programlisting language="html" linenumbering="unnumbered">
<![CDATA[<h1>This is a level 1 heading.</h1>
<h2>This is a level 2 heading.</h2>
<h3>This is a level 3 heading.</h3>
<p>This is a paragraph, with <b>bold</b> and <i>italics</i>.
<li>This is a bulleted list item.
<input type="submit" id="foo" value="This is a button">
<input type="text" id="foo" value="This is a text box">]]>
</programlisting>
</section>
<section id="_a_more_complicated_willow_example">
<title>A more complicated Willow example</title>
<simpara>BLABLABLA</simpara>

</section>
<section id="_api_documentation">
<title>API documentation</title>
<note><simpara>Whenever <literal>selector</literal> is omitted, the selector "<literal>body</literal>" is
implied, which means you are referring to the entire body of the HTML
document.</simpara></note>
<note><simpara>By specifying an integer, or a sequence of integers, for
<literal>number</literal>, you can operate directly on clients other than the one
associated by default with the current session thread.</simpara></note>
<note><simpara>Whenever <literal>argument</literal> is a file descriptor that can be read from,
the contents of the file are automatically substituted.</simpara></note>
<variablelist>
<varlistentry>
<term>
<literal>me()</literal>
</term>
<listitem>
<simpara>
  Returns the number of the current client.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>set(argument, [selector], [number])</literal>
</term>
<listitem>
<simpara>
  Set the content of the HTML element(s) referred to by <literal>selector</literal> on
  to be <literal>argument</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>add(argument, [selector], [number])</literal>
</term>
<listitem>
<simpara>
  Add <literal>argument</literal> to the content of the HTML element(s) referred to by
  <literal>selector</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>push(argument, [selector], [number])</literal>
</term>
<listitem>
<simpara>
  Add the CSS style <literal>argument</literal> to the HTML element(s) referred to by
  <literal>selector</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>pop(argument, [selector], [number])</literal>
</term>
<listitem>
<simpara>
  Add the CSS style <literal>argument</literal> to the HTML element(s) referred to by
  <literal>selector</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>hide([selector], [number])</literal>
</term>
<listitem>
<simpara>
  Hide the HTML element(s) referred to by <literal>selector</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>show([selector], [number])</literal>
</term>
<listitem>
<simpara>
  Show the HTML element(s) referred to by <literal>selector</literal>, if previously
  hidden.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>peek([selector], [number])</literal>
</term>
<listitem>
<simpara>
  Request the contents of the HTML element(s) referred to by
  <literal>selector</literal> to be posted. Intended to be used with <literal>&lt;input&gt;</literal>
  elements.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>hold([number])</literal>
</term>
<listitem>
<simpara>
  Stop executing subsequent <literal>set</literal>, <literal>add</literal>, <literal>push</literal>, <literal>pop</literal>, <literal>hide</literal>,
  <literal>show</literal>, and <literal>peek</literal> immediately, but instead stuff them in a buffer
  where they sit until <literal>flush()</literal> is called.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>flush([number])</literal>
</term>
<listitem>
<simpara>
  Execute all <literal>set</literal>, <literal>add</literal>, <literal>push</literal>, <literal>pop</literal>, <literal>hide</literal>, <literal>show</literal>, and <literal>peek</literal>
  actions that were held in a buffer since <literal>hold()</literal> was called, and
  from here on out resume executing such actions immediately without
  buffering.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>put(tuple, [delay])</literal>
</term>
<listitem>
<simpara>
  After an optional <literal>delay</literal> in seconds, post the tuple onto the
  communication board.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<warning><simpara>In Python, the value <literal>x</literal> is the same as <literal>(x)</literal>, but it is not the
    same as the one-element tuple containing it, which is written
    <literal>(x,)</literal>.</simpara></warning>
<variablelist>
<varlistentry>
<term>
<literal>get(*queries)</literal>
</term>
<listitem>
<simpara>
  Block until a tuple becomes present on the board that matches at
  least one of the queries, then return it. A tuple on the board
  matches a query whenever the tuple on the board and the query have
  the same length, and each element of the query is either <literal>None</literal> or
  identical to the corresponding element in the tuple on the board.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>grab(*queries)</literal>
</term>
<listitem>
<simpara>
  If a tuple is present on the board that matches at least one of the
  queries return it; otherwise return <literal>None</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>run(session, [port])</literal>
</term>
<listitem>
<simpara>
  This starts the Willow web server on the specified port (or port
  8000 if you leave the second argument out). The web server will
  create a thread for each client that connects, and each thread will
  run the <literal>session</literal> function. Within each thread, the <literal>me()</literal> function
  will return a different value, and <literal>add</literal>, <literal>set</literal>, etc. will by
  default operate on a different client. The web server will search
  for requested files in the current directory, among other places, so
  you can for instance include images in your pages.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>config(filename)</literal>
</term>
<listitem>
<simpara>
  Reads a configuration file in JSON format (<ulink url="http://json.org/">http://json.org/</ulink>) and
  returns a corresponding Python object. For instance, if you have a
  file <literal>protocol.txt</literal> containing the text <literal>{ "rounds" : 12, "subjects"
  : 4}</literal> then <literal>cfg = willow.config("protocol.txt")</literal> will set the
  variable <literal>cfg</literal> to the python dictionary <literal>{u'rounds': 12,
  u'subjects': 4}</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<warning><simpara>The letter <literal>u</literal> appears in front of the strings that come out
  of <literal>config</literal> because JSON strings are Unicode, not ASCII, but you do
  not need to worry; to get the value of the <literal>rounds</literal> parameter,
  simply use <literal>cfg["rounds"]</literal>.</simpara></warning>
<variablelist>
<varlistentry>
<term>
<literal>log(x,y,&#8230;)</literal>
</term>
<listitem>
<simpara>
  Write (x,y,&#8230;) to the log file as a record. A new log file is
  created in the <literal>log</literal> folder whenever the Willow library is loaded,
  and it bears a name based on the date and time when it was
  created. The log files are in CSV format and can be opened with a
  text editor or a spreadsheet program.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_willow_css_tricks">
<title>Willow CSS tricks</title>
<simpara>Some Willow features are accessed by means of CSS classes:</simpara>

<variablelist>
<varlistentry>
<term>
<literal>hidden</literal>
</term>
<listitem>
<simpara>
        Any element that has class <literal>hidden</literal> turned on will start out
        hidden. You can call <literal>show()</literal> on it to make it
        appear. Example: <literal>&lt;p&gt;At the moment, you can&lt;span
        class="hidden"&gt;not&lt;/span&gt; trade widgets.&lt;/p&gt;</literal>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bait</literal>
</term>
<listitem>
<simpara>
        Any element that has class <literal>bait</literal> turned on will automatically
        get the additional class <literal>mouse</literal> turned on whenever the mouse
        pointer is positioned over that element. This can be used to
        create "hover" effects.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_kiosk_mode_browsing">
<title>Kiosk mode browsing</title>
<simpara>In order to prevent subjects from fiddling around with the web browser
used to display a user interface to them, you can use a "kiosk mode"
web browser. While several web browsers have kiosk modes, I have found
that Google Chrome is the most convenient. On Linux, you simply use
the command line <literal>google-chrome &#8212;kiosk</literal> instead of just
<literal>google-chrome</literal>, and you get a full-screen browser without any
extraneous bits of user interface that subjects might accidentally
click on.</simpara>

</section>
<section id="_architecture">
<title>Architecture</title>
<simpara>In this section, I will describe some of the nuts and bolts of
Willow. It is not usually necessary to understand this, but it may be
helpful for those seeking to extend Willow or satisfy their curiosity.</simpara>

<simpara>The core of willow is made up of <literal>willow/willow.py</literal> and
<literal>willow/willow.js</literal> (which is included by <literal>willow/index.html</literal>). In
<literal>willow.py</literal>, the function <literal>run</literal> is defined, which starts a web
server. This web server serves GET requests in pretty much the normal
way, but it does something special using POST requests. In particular,
it expects POST requests to be Ajax calls ("<literal>XMLHttpRequest</literal>") from
<literal>willow.js</literal>. In fact, each running instance of <literal>willow.js</literal> (and there
is one per client) will always have one such request outstanding; when
a response comes in, a new one is generated immediately. This means
that the web server always has a way of talking to the client: it can
respond to the outstanding POST request. In order to keep track of the
outstanding POST requests, the web server is multithreaded; each
request gets its own thread. The web server threads, in their turn,
decide what to reply to a POST request by looking on a queue.</simpara>

<simpara>For each client, there is a separate queue. Each client generates, in
JavaScript, a UUID, which it submits when it first connects, and which
the web server can use to map a POST request to the correct queue. The
reason that we do not use the sequential client numbers for this
purpose is that the way the protocol works implies that the first
contact is made by the client, and the clients have no way of doing
the communication required to make sure their client IDs are
sequential before they are actually talking to the server. UUIDs, on
the other hand, which are hashes of the wall clock time and a random
number, can be generated in a decentralized way. Once clients connect,
they are also assigned a sequential client number, which is exposed to
the user.</simpara>

<simpara>The web server does not busy itself with putting things on the
queues. That is what session threads are for. One session thread is
started each time a client connects for the first time. The session
thread is configurable; in fact, in runs whatever <literal>session</literal> function
is passed to <literal>run()</literal>. Each session thread is assigned a name which is
the sequential client number, and the queues are made indexable by
these numbers as well. (Note that this means we have two different
tables pointing to the same queues, one indexed by UUID, and one by
client number.)</simpara>

<simpara>It is these <literal>session</literal> functions that put things onto the queues. Each
session function has access to each of the queues, indexed by client
number, but it typically uses functions that automatically fill in the
client number that the particular session thread is associated
with. This is accomplished, of course, by looking at the thread name
of the current thread.</simpara>

<simpara>Last, we come to the tuple space. This is largely a convenience, and
could be used independently of the rest of Willow, but it has proven
to be a convenient way of doing IPC between the threads without
needing to understand overly complicated concurrency primitives.</simpara>

<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="architecture.png"/>
  </imageobject>
  <textobject><phrase>architecture.png</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</article>
