Programming for Experimental Economists
=======================================

:icons:
:toc:

About this manual
-----------------

You are reading the manual for Willow, a Python framework for
experimental economics. This manual presumes that you already have an
understanding of experimental economics, of HTML, and of Python
programming.

If you are interested in learning about experimental economics, you
could do worse than to have a look at the following textbooks:

* Daniel Friedman, 'Experimental Methods: A Primer for Economists'
* John Kagel and Alvin Roth, 'The Handbook of Experimental Economics'

In order to get started with Python if you already know how to program
in some other language, you can try

* Mark Pilgrim, 'Dive into Python' (http://diveintopython.org)
* Guido van Rossum et al., 'The Python Tutorial'
  (http://docs.python.org/tutorial/)

If you want to learn both the craft of computer programming and the
Python programming language at the same time, you are in luck, since
Python is an excellent first language. Some free resources include:

* Jeffrey Elkner, Allen B. Downey, and Chris Meyers, 'How to Think
  Like a Computer Scientist'
  (http://openbookproject.net/thinkCSpy/)
* Swaroop C. H., 'A Byte of Python'
  (http://www.swaroopch.com/notes/Python)

Why Willow?
-----------

Willow is a tool for writing the kinds of computer interfaces
typically used in experimental economics. Typically, such interfaces
are designed from scratch, or by modifying earlier from-scratch
software written for similar experiments. Using Willow, you can do the
same thing, but you will be done faster and the product will be more
robust. That, at least, is the idea.

Willow sets out to accomplish this goal not by providing canned
routines for commonly performed experiments. After all, it is
precisely because our experiments are in some way different from what
has gone before that we bother doing them. Rather, Willow is a generic
toolkit that just so happens to make a lot of the things we do in
experimental economics pretty easy.

A running Willow program consists of server and a number of
clients. The clients are web browsers and the server is a Python
program created using the +willow+ library. Inside the server, there
is one 'session thread' corresponding to each client; session threads
are created automatically as clients connect to the server. Each
session thread is capable of manipulating the contents of the web page
displayed on its corresponding client browser, receiving input from
that client browser, and of posting and reading 'notes' on a common
'board' that the session threads use to communicate with one another.

Diving in
---------

Let us look at a simple example. Copy the following into a file called
+simple.py+ and run it, then point a web browser to
+http://localhost:8000+.

----------------------------------------------------------------------
import willow

@willow.experiment
def session(client, board):
    client.append("""<p>Please enter your name.</p>
                     <input id='bid' type='text' />
                     <input id='submit' type='submit' />""")
    client("#submit").click()
    name = client("#bid").data()
    client.append("<p>Hello, %s.</p>" % name)
----------------------------------------------------------------------

NOTE: In this section, I will assume that you have a computer with
Python 2.6 and Willow installed properly, as well as a modern web
browser, and that you know how to run Python programs.

You should now see a screen with the text 'Please enter your name',
followed by a text input box and a button labeled 'Submit'. If you
enter +Jaap Weel+ into the box and click the button, an additional
line of text will appear in the browser window: 'Hello, Jaap Weel.'

The previous example shows how a session thread is created and how it
communicates with the client. Next, we will see how session threads
use the 'board' to communicate with each other. This program will let
one user input their name, and then display that name to the second
user. Run the following program, and this time, open 'two' browser
windows to +http://localhost:8000+.

----------------------------------------------------------------------
import willow

@willow.experiment
def session(subject, board):
    if board.grab("token"):	# Greeter
        subject.append("""<p>Please enter your name.</p>
                          <input id='bid' type='text' />
                          <input id='submit' type='submit' />""")
        subject("#submit").click()
        name = subject("#bid").data()
        subject.put("name", name)
    else:			# Receiver
        _, name = subject.get("name", None)
        subject.append("<p>Greetings from %s</p>" % name)
----------------------------------------------------------------------

Each browser window calls into being a separate session thread, but
the behavior of each thread is described by the same function. Thus,
there needs to be a way for the session to figure out which role it
has. It does so by trying to grab a note from the board with just one
item on it: +"token"+. Exactly one such note is provided on the board
automatically, so only one of the two session threads can grab it and
assume the role of Greeter; the other session thread will assume the
role of Receiver. The Greeter proceeds to sollicit a name, just as
before, but now instead of displaying it back to the client it is
associated with, it puts a note on the board with two items: the
string +"name"+, and the actual name coming from the client. The
Receiver, on the other hand, looks for a note on the board with two
items, of which the first is the string +"name"+, and the second can
be anything. Because it calls +board.get+, rather than +board.grab+,
it will quietly wait until such a note becomes available, at which
point it takes the note off the board and continues. It reads the note
and finds out what is in its second item. (The first item is not of
interest, because the request specified that the receiver is only
interested in notes that start with +"name"+. When the Receiver has
gotten its note, it now knows the name that the Greeter got from its
client and posted on the board. The Receiver can then proceed to
display an appropriate greeting.


